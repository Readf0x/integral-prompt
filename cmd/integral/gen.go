// The following directive is necessary to make the package coherent:

//go:build ignore

// This program generates buildinfo.go. It can be invoked by running
// go generate
package main

import (
	"encoding/json"
	"fmt"
	"integral/config"
	"log"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/go-git/go-git/v6"
	"github.com/go-git/go-git/v6/plumbing"
	"github.com/invopop/jsonschema"
)

const buildFile = "cmd/integral/buildinfo.go"
const schemaFile = "share/integral/schema.json"
const sampleFile = "sample-config.json"

func main() {
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	if (strings.HasSuffix(cwd, "/cmd/integral")) {
		err = os.Chdir(strings.TrimSuffix(cwd, "/cmd/integral"))
		if err != nil {
			log.Fatal(err)
		}
		cwd = strings.TrimSuffix(cwd, "/cmd/integral")
	}
	bFile, err := os.Create(buildFile)
	if err != nil {
		log.Fatal(err)
	}
	defer bFile.Close()

	var hash, tag string
	if len(os.Args) < 2 {
		repo, err := git.PlainOpen(cwd)
		if err != nil {
			log.Fatal(err)
		}
		head, err := repo.Head()
		if err != nil {
			log.Fatal(err)
		}
		hash = head.Hash().String()

		tags, err := repo.Tags()
		if err != nil {
			log.Fatal(err)
		}

		var latestTag string
		var latestTime time.Time

		err = tags.ForEach(func(ref *plumbing.Reference) error {
			tagObj, err := repo.TagObject(ref.Hash())
			if err == nil {
				// Annotated tag
				commit, err := tagObj.Commit()
				if err != nil {
					return err
				}
				if commit.Committer.When.After(latestTime) {
					latestTag = ref.Name().Short()
					latestTime = commit.Committer.When
				}
			} else {
				// Lightweight tag
				commit, err := repo.CommitObject(ref.Hash())
				if err != nil {
					return nil // skip invalid ref
				}
				if commit.Committer.When.After(latestTime) {
					latestTag = ref.Name().Short()
					latestTime = commit.Committer.When
				}
			}
			return nil
		})
		if err != nil {
			log.Fatal(err)
		}
		if latestTag == "" {
			tag = "unset"
		} else {
			tag = latestTag
		}
	} else {
		hash = os.Args[1]
		tag = os.Args[2]
	}

	fmt.Printf("Commit: %s\nTag: %s\n", hash, tag)

	temp.Execute(bFile, buildinfo{
		Commit: hash,
		Tag:    tag,
	})

	jFile, err := os.Create(schemaFile)
	if err != nil {
		log.Fatal(err)
	}
	defer jFile.Close()

	schema, err := jsonschema.Reflect(&config.PromptConfig{}).MarshalJSON()
	if err != nil {
		log.Fatal(err)
	}
	jFile.Write(schema)

	j2File, err := os.Create(sampleFile)
	if err != nil {
		log.Fatal(err)
	}

	sample, err := json.MarshalIndent(config.GetDefault(), "", "  ")
	if err != nil {
		log.Fatal(err)
	}
	j2File.Write(sample)
}

var temp = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
package main

const Commit = "{{ .Commit }}"
const Version = "{{ .Tag }}"
`))

type buildinfo struct {
	Commit string
	Tag    string
}
